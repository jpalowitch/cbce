% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/cbce.R
\name{cbce}
\alias{cbce}
\title{Correlation Bi-community Extraction method}
\usage{
cbce(X, Y, alpha = 0.05, OL_thres = 0.9, exhaustive = FALSE,
  OL_tol = Inf, Dud_tol = Inf, time_limit = 18000, updateMethod = 1,
  init_method = "conservative-BH", inv.length = TRUE, start_nodes = NULL,
  parallel = FALSE, calc_full_cor = FALSE, backend = "chisq",
  diagnostics = diagnostics1)
}
\arguments{
\item{X, Y}{Numeric Matices. Represents the two groups of variables.}

\item{alpha}{\eqn{\in (0,1)}. Controls the type1 error per update. This is the type1 error to use for BH procedure}

\item{OL_thres}{\eqn{\in (0,1)}. Threshold  used to conclude significant overlap. The sets have significant overlap if jaccard similarity is >= OL_thres.}

\item{exhaustive}{Boolean. If exhaustive is FALSE, new extractions are not started from nodes within found communities. Otherwise, attempt is made to start from all nodes.}

\item{OL_tol}{If more than OL_tol found communities have OL_thres overlap, stop method.}

\item{Dud_tol}{If more than Dud_tol initializations end in a dud, stop method.}

\item{time_limit}{Stop method after time_limit seconds.}

\item{updateMethod}{Use the 1(-step) update vs 2(-step) update}

\item{init_method}{The initialization procedure to use. Must be one of "conservative-BH", "non-conservative-BH", "BH-0.5", "no-multiple-testing".}

\item{inv.length}{Logical. Use inv.length as score while selecting the smallest community from communities with significant overlap.}

\item{start_nodes}{The initial set of nodes to start with. If Null start from all the nodes (may still exclude nodes within found communities if exhaustive = FALSE).}

\item{parallel}{Use parallel processing.}

\item{calc_full_cor}{Calculate \code{c(ncol(X),ncol(Y))} dimensional correlation matrix. This makes the computation faster but requires more memory.}

\item{backend}{The engine to use for p-value computation. Currently must be one of "normal", "normal_two_sided", "chisq".}

\item{diagnostics}{This is a function that is called whenever internal events happen. It can then collect useful meta-data which is added to the final resutls.}
}
\value{
The return value is a list with details of the extraction and list of indices representing the communities. See example below (finding communities in noise). Note that the variables from the X and Y set are denoted using a single numbering. Hence the nodes in X are denoted by \code{1:dx} and the nodes in Y are denoted by the numbers following dx (hence \code{dx+1:dy})
}
\description{
Given two groups of variables, find correlation bi-communities between them. For such a community, the nodes from the first group are are higly correlated to the community-nodes from the second group, and vice versa.
}
\details{
\code{cbce} applies an update function (mapping subsets of variables to subsets of variables) iteratively until a fixed point is found. These fixed points are reported as communities. The update function uses multiple-testing procedure to find variables correlated to the current set of variables.

The update starts from a single node (starting with the initialization step) and is repeated till either a fixed point is found or some set repeats. Each such run is called an extraction. Since the extraction only starts from singleton node, there are \code{ncol(X)+ncol(Y)} possible extractions.
}
\examples{
\dontrun{
n <- 100
dx <- 50
dy <- 70

X <- matrix(rnorm(n*dx), ncol=dx)
Y <- matrix(rnorm(n*dy), ncol=dy)
res <- cbce(X, Y)
finalComms <- lapply(res$extract_res[res$finalIndxs], function(r) r$StableComm)
}
}
